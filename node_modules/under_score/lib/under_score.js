// under_score, extend Underscore with a motley collection of various helpers
// (c) Zed Zhou,  https://github.com/mhzed/under_score
// under_score is freely distributable under the MIT license.

//noinspection ThisExpressionReferencesGlobalObjectJS,ThisExpressionReferencesGlobalObjectJS
(function() {

function extend(_) {
_.mixin({
    // env is one of
    // "unknown"    : undetermined
    // "module"     : inside env that supports "module" and "require", aka nodejs
    // "amd"        : inside requirejs AMD (asynchronous module definition)
    // "script"     : inside <script> tag in browser
    env     : "unknown",

    /******************************************************************************
     *  Date/Time related helpers
     ******************************************************************************/

	// 610 => 10:10  (10 hours + 10 minutes is 610 minutes)
	prettyMinutes : function(minutes, prependSign) {
		var ret = '';
		if (prependSign) ret += minutes < 0 ? '-' : '+';
		minutes = Math.abs(minutes);
		var hours = Math.floor(minutes / 60);
		ret += _("%02d").format(hours);
		ret += _(":%02d").format(minutes%(hours*60));
		return ret;
	},
    // returns "2010-01-01 00:00:00Z" or "2010-01-01 00:00:00+08:00"
    dateTimeZoneStr : function(date) {
		var off = date.getTimezoneOffset();
		var strZone = (off==0?'Z':_(off).prettyMinutes(true));
        return _('%04d-%02d-%02d %02d:%02d:%02d%s').format(date.getFullYear(), date.getMonth()+1, date.getDate(),
            date.getHours(), date.getMinutes(), date.getSeconds(), strZone);
    },
    // returns "2010-01-01 00:00:00"
    dateTimeStr : function(date) {
        return _('%04d-%02d-%02d %02d:%02d:%02d').format(date.getFullYear(), date.getMonth()+1, date.getDate(),
            date.getHours(), date.getMinutes(), date.getSeconds());
    },
    // returns "2010-01-01"
    dateStr : function(date) {
        return _('%04d-%02d-%02d').format(date.getFullYear(), date.getMonth()+1, date.getDate());
    },
    // returns "00:00:00"
    timeStr : function(date) {
        return _('%02d:%02d:%02d').format(date.getHours(), date.getMinutes(), date.getSeconds());
    },

    /******************************************************************************
     *  Type related helpers: attempting to bring strong type checking to javascript
     ******************************************************************************/

    // return o's type, relies on underscore's is*() helpers, not terribly efficient but works
    type : function(o) {
        var wrap = _(o);
        if (wrap.isElement())           return "element";
        else if (wrap.isArray())        return "array";
        else if (wrap.isObject())       return "object";
        else if (wrap.isArguments())    return "argument";
        else if (wrap.isFunction())     return "function";
        else if (wrap.isString())       return "string";
        else if (wrap.isNumber())       return "number";
        else if (wrap.isNaN())          return "nan";
        else if (wrap.isBoolean())      return "boolean";
        else if (wrap.isDate())         return "date";
        else if (wrap.isRegExp())       return "regexp";
        else if (wrap.isNull())         return "null";
        else if (wrap.isUndefined())    return "undefined";
        else return "unknown";
    },

    // typeCheck ensure obj is same as templateObj:
    // * all keys in templateObj must exist in obj, and value must be of same type
    // * keys exist in obj only are allowed
    // returns null if check passed, or an object containing details of mis-match
    // Example:
    // _.typeCheck( { a : 1 }, { } ) returns { a : "missing" }
    // _.typeCheck( { a : 1 }, { a : "2" } ) returns { a : "type-mismatch: expect number but was string" }
    typeCheck : function(templateObj, obj)
    {
        var ret = {};
        _(templateObj).each( function(v, k){
            if (!(k in obj))
                ret[k] = "missing";
            else {
                var dtype = _(v).type(), ptype = _(obj[k]).type();
                if (dtype != ptype)
                    ret[k] = _("type-mismatch: expect %s but was %s").format(dtype, ptype);
                else {
                    if (ptype == "object") {
                        var subCheck = _.typeCheck(v, obj[k]);
                        if (subCheck) ret[k] = subCheck;
                    }
                }
            }
        });
        if (_(ret).keys().length==0) return null;
        else return ret;
    },
    // recursively attempt to convert values in obj to be of same type as templateObj,
    // returned object has keys that are intersect of templateObj and obj (default, see param loose), with value from
    // "obj" converted to type defined in "templateObj"
    // when converting array to array, only first element in "templateObj" is used as reference type
    // param loose:  when converting obj to obj, if loose is true, then all keys in "obj" are kept
    // if conversion is senseless: i.e.  "a" to [], then no conversion occurs
    // _.typeConvert("1", 2) returns "2"
    // _.typeConvert( {x: 1}, {x: "2"} ) returns {x: 2}
    // _.typeConvert( {xs: [1]}, {xs : ["2"]} ) returns {xs : [2] }
    // _.typeConvert( {xs: 1}, {xs : ["2"]} ) returns {xs : ["2"] }
    // _.typeConvert( [ {xs: 1} ], [ {xs: "2"} ] ) returns [ {xs: 2} ]
    typeConvert : function(templateObj, obj, loose) {
        var fromType = _.type(obj),
            toType   = _.type(templateObj),
            ret;
        if (fromType == 'string') {
            if (toType == "number") ret = parseInt(obj);
            else if (toType == "boolean") ret = !(!obj);
            else if (toType == "regexp") ret = new RegExp(obj);
            else if (toType == "date") ret = new Date(obj);
        } else if (fromType == 'number') {
            if (toType == "string") ret = ""+obj;
            else if (toType == "boolean") ret = !(!obj);
            else if (toType == "date") ret = new Date(obj);  // obj is ms Jan 1, 1970
        } else if (fromType == 'boolean') {
            if (toType == "string") ret = obj.toString();
            else if (toType == "number") ret = obj?1:0;
        } else if (fromType == 'date') {
            if (toType == 'string') ret = obj.toString();
            else if (toType == 'number') ret = obj.valueOf();
        } else if (fromType == 'array') {
            if (toType == 'array') {
                ret = _.reduce(obj, function(memo, v) {
                    memo.push(_.typeConvert(templateObj[0], v));
                    return memo;
                }, []);
            }
        } else if (fromType == 'object') {
            if (toType == 'object') {
                ret = _.reduce(obj, function(memo, v, k) {
                    if (loose || k in templateObj)
                        memo[k] = _.typeConvert(templateObj[k], v);
                    return memo;
                }, {});
            }
        } else if (fromType == 'argument') {
            if (toType == 'array') ret = Array.prototype.slice.call(obj, 0);
        }
        if (ret === undefined) ret = obj;
        return ret;

    },

    /******************************************************************************
     *  Object related helpers
     ******************************************************************************/

    // pick selected keys from object using iterator callback
    // _({a:1,b:2,c:3}).pick(function(v,k){ return k=='a'||k=='b'}) => {a:1,c:3}
    pick : function(object, iterator) {
        return _(object).reduce(function(o, v, k){
            if (iterator(v,k))
                o[k] = v;
            return o;
        }, {});
    },
    // pick keys in 'object' that are also in 'keys', return object with picked keys
    // keys: array of keys, or an object
    // _({a:1,b:2,c:3}).pickKeys(['a']) => {a:1}
    pickKeys : function(object, keys) {
        var keySet;
        if (_(keys).isArray()) keySet = _(keys).reduce(function(s,k){ s[k]=true; return s;}, {});
        else keySet = keys;
        return _(object).pick(function(v,k){
            return k in keySet;
        });
    },
    // return defaultVal if key does not exist in object
    // var x = _(object).fetch('x', 0);
    fetch : function(object, key, defaultVal) {
        return (key in object) ? object[key] : defaultVal;
    },

	// OOP simulator
	// _(ChildType).inherites(BaseType); or _.inherites(ChildType, BaseType);
	// where BaseType is a function name (normal inheritance), or an object (pure virtual)
    // in ChildType constructor, then call:
    // this.parent.constructor.call(this, ...);
	inherites: function( derivedClass, parentClassOrObject ) {
        if ( parentClassOrObject.constructor == Function ) // parentClassOrObject is function
        {
            //Normal Inheritance
            derivedClass.prototype = new parentClassOrObject;
            derivedClass.prototype.constructor = derivedClass;
            derivedClass.prototype.parent = parentClassOrObject.prototype;
        }
        else
        {
            //Pure Virtual Inheritance, because you can't new parentClassOrObject() as parentClassOrObject is an object
            derivedClass.prototype = parentClassOrObject;
            derivedClass.prototype.constructor = derivedClass;
            derivedClass.prototype.parent = parentClassOrObject;
        }
        return derivedClass;
    },

    /******************************************************************************
     *  Array/String helpers
     ******************************************************************************/

    // array is modified
    // _([1,2]).swap(0,1) => [2,1]
    swapAt : function(array, i, j) {
        var temp = array[i];
        array[i] = array[j];
        array[j] = temp;
        return array;
    },
    // array is modified
    // _([1,2]).append([3,4]) => [1,2,3,4]
    append : function(array, appendArray) {
        array.push.apply(array, _(appendArray).isArray()?appendArray:[appendArray]);
        return array;
    },

    // shortcut to find a single element in array that matches condition (iterator)
    finde : function(array, iterator, context) {
        var results = _(array).filter(iterator, context);
        if (results.length >0 ) return results[0];
        else return null;
    },

    // duplicate array or string x times
    // 'list' is not modified
    // [1,2].multiply(3) => [1,2,1,2,1,2]
    multiply : function(list, count) {
        var ret;
        if (_.isString(list))
            ret = '';
        else if (_.isArray(list))
            ret = [];
        else
            throw new Error(_("%s is not supported").format(typeof list));
        for (var i=0; i< count; i++) ret = ret.concat(list);
        return ret;
    },

    // lhs or rhs can be array or string
    // strcmp type of compare where returns -1 (<), 0 (==), 1 (>)
    compare : function(lhs, rhs, comparator /* function(left, right) : -1,0, 1*/) {
        if (_.isString(lhs)) {
            return lhs < rhs ? -1 : ( lhs === rhs ? 0 : 1); 
        }
        for (var i = 0, l = Math.min(lhs.length, rhs.length); i < l; i++) {
            if (comparator) {
                var r = comparator(lhs[i], rhs[i]);
                if (r!=0) return r;
            }
            else {
                if (lhs[i] < rhs[i]) return -1;
                else if (lhs[i] > rhs[i]) return 1;
            }
        }
        if (lhs.length < rhs.length) return -1;
        else if (lhs.length == rhs.length) return 0;
        else return 1;
    },

    /******************************************************************************
     *  String helpers
     ******************************************************************************/

    // native js .join does not support iterator, therefore joinStr.
    // example: _([1,2,3]).joinStr(' + ', function(e) { return e*2; }) === "2 + 4 + 6";
    joinStr : function(array, separator, iterator) {
        return _(array).chain().reduce(function(res, elem) {
            return res + iterator(elem) + separator;
        }, "").cut(separator.length).value();
    },

    // cut how many chars|elements from string|array, >0 means cut at the end, <0 means cut at the beginning
    // cut(n) same as _.initial(n) if n>0
    // cut(n) same as _.tail(abs(n)) if n<0
    cut  : function(list, howmany) {
        if (howmany>0)
           return list.slice(0, list.length-howmany);
        else
           return list.slice(-howmany, list.length);
    },

    // trim string of leading and trailing characters
    // charset: set of characters to trim, optional, default is whitespace
    trim : function(str, charset) {
        var re;
        if (charset === undefined)
           re = /^\s+|\s+$/g;
        else {
            charset = _(charset).escapeRegExp();
            re = new RegExp(_("^[%s]+|[%s]+$").format(charset, charset), "g");
        }
        return str.replace(re, '');
    },
    // make str a proper sentence: replace multiple whitespaces with a single space
    prettySentence : function(str) {
        return str.replace(/\s+/g, ' ').trim();
    },
    // convert hyphenated string to camcelCase
    camelCase : function(str) {
        return str.replace(/-\D/g, function(match){
            return match.charAt(1).toUpperCase();
        });
    },
    // convert camelCase string to hyphenate
    hyphenate : function(str) {
        return _(str.replace(/[A-Z]/g, function(match){
            return ('-' + match.charAt(0).toLowerCase());
        })).trim('-');
    },
    // capitalize first character of word in a sentence
    capitalize : function(str){
        return str.replace(/\b[a-z]/g, function(match){
            return match.toUpperCase();
        });
    },
    // escape str for safe regex expression
    escapeRegExp : function(str){
        return str.replace(/([-.*+?^${}()|[\]\/\\])/g, '\\$1');
    },
    // returns if str ends with substr
    endsWith  : function(str, substr) {
        var pos = str.lastIndexOf(substr);
        if (pos == -1) return false;
        else return  pos + substr.length == str.length;
    },
    // count number of occurrences of pattern in str, pattern can only be string
    count  : function(str, pattern) {
        var pos=0;
        var cnt = 0;
        while ((pos = str.indexOf(pattern, pos))!=-1) {
            cnt++;
            pos += pattern.length;
        }
        return cnt;
    },

    /********************************************************************************************************
     *  useful path manipulation methods, similar to nodejs, but works inside browser.  Some function
     *  names are not camel-cased to follow node's naming convention
     ********************************************************************************************************/

    // Return the directory name of a path.
    // returns director name (everything before last occurrence of /, excluding last /), similar to the Unix
    // dirname command.
    dirname : function(str) {
        var m = /^(.*)[\/\\]([^\/\\]*)$/.exec(str);
        if (m) return m[1];
        else return '';
    },
    // Return the last portion of a path. Similar to the Unix basename command.
    basename : function(str, ext) {
        var m = /^(.*)[\/\\]([^\/\\]*)$/.exec(str);
        if (m)
            return _(m[2]).endsWith(ext) ? _(m[2]).cut(ext.length) : m[2] ;
        else
            return str;
    },
    // Return the extension of the path, from the last '.' to end of string in the last portion of the path. If there
    // is no '.' in the last portion of the path or the first character of it is '.', then it returns an empty string.
    extname : function(str) {
        var m = /^.+(\.[^\/\\\.]*)$/.exec(str);
        return m ? m[1] : "";
    },
    // same as nodejs path.join
    pathjoin : function() {
        var ret = "";
        _(arguments).each(function(a) {
            if (!_(ret).endsWith("/") && ret.length>0) ret += "/";
            ret += a;
        });
        return ret;
    },
    // return if path is absolute path
    isAbsPath : function(path) {
        return (path[0] == '/' ||                // unix /path
                path[1] == ':' ||                // windows c:\path
                /^(http|https):/.test(path) );    // http: or https:
    },

    // pathResolve that works in server or client
    // note: in returned value, \ is always replaced by /, even in windows nodejs
    // in nodejs
    // * if first arg contains :/ or :\, or starts with / or \, then treated as full path, uses local logic to resolve
    // * otherwise, falls back to nodejs path.resolve (with \ replaced by /)
    // in browser:
    // * if first arg contains :/ or :\, treated as full url,
    // * if first arg contains //, treated as full url using window.location.protocol
    // * if first arg contains /, treated as abs path at window.location.protocol + window.location.host
    // * otherwise, resolve relative to window.location.protocol + "//" + window.location.host + window.location.pathname
    pathResolve : function(first) {
        var args = _(arguments).toArray();

        var ret;

        //// deals with full path detection/handling
        if (/:(\/|\\)/.test(first)) // contains :/  or :\, assumes we have a full url!
            ret = first.replace(/\\/g, "/") ;
        else {      // no :/ found
            if (_.env == "module") {    // fall back to node's path.resolve
                if (first[0]=='/' || first[0]=='\\')
                    ret = first.replace(/\\/g, "/");
                else {
                    // if no abs path found, use node's path.resolve to get full path
                    var path = require("path");
                    return path.resolve.apply(path, _(arguments).toArray()).replace(/\\/g, "/");
                }
            }
            else if (window && window.location) {   // in browser
                if (/^\/\//.test(first))   //  //host/path => http://host/path
                    ret = window.location.protocol + first;     // protocol contains trailing :
                else if (first[0]=='/')    //  /path => http://host/path
                    ret = window.location.protocol + "//" + window.location.host + first;
                else {  // get current page's full location
                    ret = window.location.protocol + "//" + window.location.host + window.location.pathname;
                }
            }
            else
                throw new Error("Unable to resolve path " + JSON.stringify(_(arguments).toArray()));
        }
        // join path together
        var endsInSlash = /\\|\//.test(_(args).chain().last().last().value());
        args.shift();
        _(args).each(function(a) {
            if (!/\/$/.test(ret)) ret += "/";
            ret += _.trim(a.replace(/\\/g, "/"), "/");
        });

        // handle . or ..
        var m, frag=ret;
        ret="" ;
        while (m = /^(.*?)(\/\.\.?)(.*)$/.exec(frag)) {
            ret += m[1];
            if (m[2] !== "/.") // /.., remove trail /xxx from ret
                ret = ret.replace(/\/[^\/]+$/, '');
            frag = m[3];
        }
        ret += frag;
        if (endsInSlash) ret += '/';

        return ret;
    },

    /********************************************************************************************************
     *  Miscellaneous other helpers
     ********************************************************************************************************/

    // cross nodejs/browser version of next tick
    // if nodjes, uses process.nextTick
    // if browser, uses window.postMessage (faster than setTimeout(fn,0))
    // otherwise, uses setTimeout
    nextTick : function(cb) {
        if (_.env == 'module')
            process.nextTick(cb);
        else if (typeof window !== 'undefined') {
            // to simulate nextTick in browser, use window.postMessage, much faster than setTimeout(fn, 0);
            // http://dbaron.org/log/20100309-faster-timeouts
            if (!window.nextTick) {
                (function() {
                    var timeouts = [];
                    var messageName = "zero-timeout-message";

                    // Like setTimeout, but only takes a function argument.  There's
                    // no time argument (always zero) and no arguments (you have to
                    // use a closure).
                    function nextTick(fn) {
                        timeouts.push(fn);
                        window.postMessage(messageName, "*");
                    }
                    function handleMessage(event) {
                        if (event.source == window && event.data == messageName) {
                            event.stopPropagation();
                            if (timeouts.length > 0) {
                                var fn = timeouts.shift();
                                fn();
                            }
                        }
                    }
                    window.addEventListener("message", handleMessage, true);
                    // Add the one thing we want added to the window object.
                    window.nextTick = nextTick;
                })();
            }
            window.nextTick(cb);
        }
        else    // fall back to setTimeout
            setTimeout(cb, 0);
    },

    // C style sprintf in js, support most c style format specifiers.
    // * Following code is googled years ago and I found it to work reasonable well and bug fee.  Unfortunately I
    // lost the original source, so hat-tip to the original anonymous author.
    // example: _("%s").format('a');
    format : function (format) {
    
        var regex = /%%|%(\d+\$)?([-+\'#0 ]*)(\*\d+\$|\*|\d+)?(\.(\*\d+\$|\*|\d+))?([scboxXuidfegEG])/g;
        var a = _(arguments).toArray().slice(1),
            i = 0;
    
        var pad = function (str, len, chr, leftJustify) {
            if (!chr) {
                chr = ' ';
            }
            var padding = (str.length >= len) ? '' : (new Array(1 + len - str.length >>> 0)).join(chr);
            return leftJustify ? str + padding : padding + str;
        };
    
        var justify = function (value, prefix, leftJustify, minWidth, zeroPad, customPadChar) {
            var diff = minWidth - value.length;
            if (diff > 0) {
                if (leftJustify || !zeroPad) {
                    value = pad(value, minWidth, customPadChar, leftJustify);
                } else {
                    value = value.slice(0, prefix.length) + pad('', diff, '0', true) + value.slice(prefix.length);
                }
            }
            return value;
        };
    
        var formatBaseX = function (value, base, prefix, leftJustify, minWidth, precision, zeroPad) {
            // Note: casts negative numbers to positive ones
            var number = value >>> 0;
            prefix = prefix && number && {
                '2': '0b',
                '8': '0',
                '16': '0x'
            }[base] || '';
            value = prefix + pad(number.toString(base), precision || 0, '0', false);
            return justify(value, prefix, leftJustify, minWidth, zeroPad);
        };
    
        var formatString = function (value, leftJustify, minWidth, precision, zeroPad, customPadChar) {
            if (precision != null) {
                value = value.slice(0, precision);
            }
            return justify(value, '', leftJustify, minWidth, zeroPad, customPadChar);
        };
    
        var doFormat = function (substring, valueIndex, flags, minWidth, _, precision, type) {
            var number;
            var prefix;
            var method;
            var textTransform;
            var value;
    
            if (substring == '%%') {
                return '%';
            }
    
            // parse flags
            var leftJustify = false,
                positivePrefix = '',
                zeroPad = false,
                prefixBaseX = false,
                customPadChar = ' ';
            var flagsl = flags.length;
            for (var j = 0; flags && j < flagsl; j++) {
                switch (flags.charAt(j)) {
                case ' ':
                    positivePrefix = ' ';
                    break;
                case '+':
                    positivePrefix = '+';
                    break;
                case '-':
                    leftJustify = true;
                    break;
                case "'":
                    customPadChar = flags.charAt(j + 1);
                    break;
                case '0':
                    zeroPad = true;
                    break;
                case '#':
                    prefixBaseX = true;
                    break;
                }
            }
    
            // parameters may be null, undefined, empty-string or real valued
            // we want to ignore null, undefined and empty-string values
            if (!minWidth) {
                minWidth = 0;
            } else if (minWidth == '*') {
                minWidth = +a[i++];
            } else if (minWidth.charAt(0) == '*') {
                minWidth = +a[minWidth.slice(1, -1)];
            } else {
                minWidth = +minWidth;
            }
    
            // Note: undocumented perl feature:
            if (minWidth < 0) {
                minWidth = -minWidth;
                leftJustify = true;
            }
    
            if (!isFinite(minWidth)) {
                throw new Error('sprintf: (minimum-)width must be finite');
            }
    
            if (!precision) {
                precision = 'fFeE'.indexOf(type) > -1 ? 6 : (type == 'd') ? 0 : undefined;
            } else if (precision == '*') {
                precision = +a[i++];
            } else if (precision.charAt(0) == '*') {
                precision = +a[precision.slice(1, -1)];
            } else {
                precision = +precision;
            }
    
            // grab value using valueIndex if required?
            value = valueIndex ? a[valueIndex.slice(0, -1)] : a[i++];
    
            switch (type) {
            case 's':
                return formatString(String(value), leftJustify, minWidth, precision, zeroPad, customPadChar);
            case 'c':
                return formatString(String.fromCharCode(+value), leftJustify, minWidth, precision, zeroPad);
            case 'b':
                return formatBaseX(value, 2, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
            case 'o':
                return formatBaseX(value, 8, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
            case 'x':
                return formatBaseX(value, 16, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
            case 'X':
                return formatBaseX(value, 16, prefixBaseX, leftJustify, minWidth, precision, zeroPad).toUpperCase();
            case 'u':
                return formatBaseX(value, 10, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
            case 'i':
            case 'd':
                number = (+value) | 0;
                prefix = number < 0 ? '-' : positivePrefix;
                value = prefix + pad(String(Math.abs(number)), precision, '0', false);
                return justify(value, prefix, leftJustify, minWidth, zeroPad);
            case 'e':
            case 'E':
            case 'f':
            case 'F':
            case 'g':
            case 'G':
                number = +value;
                prefix = number < 0 ? '-' : positivePrefix;
                method = ['toExponential', 'toFixed', 'toPrecision']['efg'.indexOf(type.toLowerCase())];
                textTransform = ['toString', 'toUpperCase']['eEfFgG'.indexOf(type) % 2];
                value = prefix + Math.abs(number)[method](precision);
                return justify(value, prefix, leftJustify, minWidth, zeroPad)[textTransform]();
            default:
                return substring;
            }
        };
    
        return format.replace(regex, doFormat);
    }
    
});
}
    var _;
    if (typeof module !== 'undefined' && module.exports) {
        // in node.js
        _ = exports = module.exports = require("underscore");
        _.env = "module";
        extend(_);
    } else if (typeof define === 'function' && define.amd) {
        // in browser via require.js (AMD) 
        define(['underscore'], function(_) {
            extend(_);
            _.env = "amd";
            return _;
        });
    }        
    else {
        // in browser via normal include: <script src='....'></script> 
	    _ = this._;
        _.env = "script";
	    extend(_);
	}

}).call(this);




